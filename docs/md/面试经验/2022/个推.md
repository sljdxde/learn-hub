### 一轮
1. 数据库主从同步原理及数据库binlog的3种类型
- 主从同步原理：
   - （1）主从同步设置好之后（进行相关的诸如ip，端口，服务id，等操作设置后）
   - （2）相关变动会写入到binlog中
   - （3）maser会启动一个线程：binlog dumplog 线程，这个线程会通知从机，当前存在SQL变更，并将binlog的变动发送到从机上
   - （4）从机收到请求后，会启动线程：i/o线程 ，该线程会将收到的binlog日志加载到中继日志delay log中
   - （5）从机中的另外一个线程：SQL 线程会读取relay日志中的信息，刷新到从机中
- 三种类型：
   - Statement：每一条修改数据都会记录到master的binlong中
   - Row：记录每一行数据修改的形式
   - Mixed：表结构变更记录成statement，其他记录为row
2. springboot的特性
- **1）自动配置** **-Auto** **Configuration**
   - **加载配置文件**
   - **声明相关类**
   - **加载配置项**
- **2）起步依赖-Starter** **Dependency**
   - 只要引入一个相应的starter-denpendency,Spring Boot就会根据我们的需要，帮助我们配置相应的依赖
- **3）命令行界面-Spring** **Boot** **CLI**
   - 

- **4）运行监控-Actuator**
   - 

3. seata原理，全局事务锁的实现
- 4种模式：AT、TCC、XA、SAGA
- 基本构成：TC（事务协调者）、TM（开启/提交/回滚全局事务）、RM（管理分支事务）
- 全局事务锁的实现：
   - 生成：TM启动全局事务时生成全局事务id，存放在数据库中
   - 加锁：在lock_table中加锁，锁住对应resource信息及关联xid
   - 解锁：判断查询出来的xid和传递过来的是否一致，一致则解锁
4. redis的setNx实现分布式锁的问题
- 问题一：加锁的客户端突然崩溃，会导致死锁问题
- 针对问题一，可以增加失效时间
- 但是增加失效时间后，无法保证初次加锁和二次加锁的客户端是同一个，会出现a加锁，超期解锁，b加锁，a解锁的现象
- 针对该问题，Redisson框架实现分布式锁的思路，就使用watchDog机制实现锁的续期。当加锁成功后，同时开启守护线程，默认有效期是30秒，每隔10秒就会给锁续期到30秒，只要持有锁的客户端没有宕机，就能保证一直持有锁，直到业务代码执行完毕由客户端自己解锁，如果宕机了自然就在有效期失效后自动解锁。
- 参考资料：[https://www.zhihu.com/question/300767410/answer/1749442787](https://www.zhihu.com/question/300767410/answer/1749442787)
5. 设计模式
- 模板模式：作为抽象类，用于定义规范
- 单例模式：懒汉、饿汉、线程安全问题（需要再次学习）
- 工厂模式：
- 抽象工厂模式：
- 策略模式：
- 装饰器模式：
- 桥模式：
6. 分库分表
- 参考`顺丰`中的回答
7. 分布式锁的其他实现方式
- zookeeper：锁节点下新建顺序编号的临时节点、判断临时节点是不是当前队列中的首节点、如果是则加锁。
- 为什么没有使用：考虑项目成本问题
- 总结一下ZooKeeper分布式锁：
   - （1）优点：ZooKeeper分布式锁（如InterProcessMutex），能有效的解决分布式问题，不可重入问题，使用起来也较为简单。
   - （2）缺点：ZooKeeper实现的分布式锁，性能并不太高。为啥呢？
因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。大家知道，ZK中创建和删除节点只能通过Leader服务器来执行，然后Leader服务器还需要将数据同不到所有的Follower机器上，这样频繁的网络通信，性能的短板是非常突出的。
   - 总之，在高性能，高并发的场景下，不建议使用ZooKeeper的分布式锁。而由于ZooKeeper的高可用特性，所以在并发量不是太高的场景，推荐使用ZooKeeper的分布式锁。
- 在目前分布式锁实现方案中，比较成熟、主流的方案有两种：
   - （1）基于Redis的分布式锁
   - （2）基于ZooKeeper的分布式锁
- 两种锁，分别适用的场景为：
   - （1）基于ZooKeeper的分布式锁，适用于高可靠（高可用）而并发量不是太大的场景；【CP】
   - （2）基于Redis的分布式锁，适用于并发量很大、性能要求很高的、而可靠性问题可以通过其他方案去弥补的场景【AP】
8. cap理论在该场景下的实践
- 简单谈下ap和cp
- 分布式锁如果要保证高可用，那么就是牺牲掉cp（数据一致性）
9. 线程安全怎么保证
- concurent包
- Atoi自增
- 线程私有变量
- 

10. 项目简单介绍
- 略

### 二轮

1. aes，rsa加密方式
- 需要了解一下数据分段加密🔐（阅读《计算机网络》）
2. http，https区别
- 建议优先阅读《计算机网络》
- 基本流程
   - 客户端发起连接请求（443端口），该请求包含一个随机值1，用于后续组装秘钥
   - 服务端收到请求后，响应该请求，返回随机值2和加密算法
   - 接下来，服务端再次进行响应，该报文中包含CA证书，证书中包含公钥、颁发时间、颁发机构、CA签名等信息
   - 客户端解析证书，验证证书是否有效，验证通过后生成一个预主秘钥
   - 使用上一步生成的预主秘钥+随机值1+随机值2，生成真正的加密秘钥，然后通过证书公钥对对称秘钥进行加密
   - 传送秘钥信息给服务端，服务端使用该秘钥进行后续加密信息的解密
3. tcp udp的区别
- 建议优先阅读《计算机网络》
- **报文格式不同**，UDP仅包含源端口、目的端口、数据包长度、校验值、数据；而TCP则复杂的多
- **重传方式不同**，UDP无发送缓冲区，因此无法重传；TCP可以重传
- TCP使用滑动窗口提高吞吐率、通过滑动窗口的大小控制流速、使用拥塞窗口进行拥塞控制
4. socket的使用
- 类型：tcp - socket 和 udp-socket
- tcp中需要2种类型的socket
5. 流程可视化要怎么实现，怎样实现拖拽方式配置流程
- 回答：xml与组件进行映射，业务和流程数据分离
- 可以参考gin的一款实现
6. 首页缓存策略
- 动静分离
- 业务数据缓存
7. mysql中解析ip地址
- 1.数值类型分析
   - 我们知道IPv4的范围是0.0.0.0 - 255.255.255.255，它占4byte，总共有2564种组合，即4,294,967,296种组合。在MySQL中，自然有用于能够提供存储服务的数据类型，我们采用**unsigned int(10)**存储IPv4，占4byte，非常的节约空间。
   - 我们知道IPv6的范围是0:0:0:0:0:0:0:0 到FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF，它占16byte。在MySQL中，自然有用于能够提供存储服务的数据类型，我们采用VARBINARY(16)（其中的16表示字节数）存储IPv6，占16byte，不仅可以使用VARBINARY(16)存储IPv6的地址，可以使用使用VARBINARY(16)存储IPv4的地址，在不确定IP地址类型的情况下可以使用VARBINARY(16)类型声明IP字段。
- IPv4在MySQL中使用：
   - INET_ATON(String ip)把String类型IPv4的ip转换为数值类型；
   - INET_NTOA(int ip)把int类型IPv4的ip转换为String类型。
- IPv6在MySQL中使用：
   - INET6_ATON(String ip)把String类型IPv6的ip转换为数值类型；
   - INET6_NTOA(int ip)把int类型IPv6的ip转换为String类型。
- 参考资料：[https://blog.csdn.net/yeahPeng11/article/details/119721456](https://blog.csdn.net/yeahPeng11/article/details/119721456)
8. 给定40w个ip和对应城市，怎样做映射
- bitmap、布隆过滤器
- 需要具体细化：
   - 

9. 怎样做数据加密及数据验证
- 秘钥非对称、数据对称
- 参数校验
10. Http1.1， Http2.0 和 Http3.0
- 参考资料：[https://zhuanlan.zhihu.com/p/266578819](https://zhuanlan.zhihu.com/p/266578819)
### HRG

1. 个人优缺点
2. 项目上的收获
3. 3、5年规划

### HRBP

1. 简单介绍一下自己，不限于工作经历，可以结合自己的成长经历进行介绍
2. 父母的职业、对自己的影响、是不是独生子女、生日
3. 大学时参与过哪些活动、获得过哪些荣誉、成绩如何、专业选择、城市选择、为什么没有写在简历上
4. 研究生为什么又选择了通信
5. 从事的项目，oa系统的建设流程，有哪些组成，工期2个月的情况下，最后的上线结果如何【该问题引导有误，不应该说2个月上线，而是做了2个月】
6. 没有如期上线的原因，事后怎么复盘，如何避免这种情况的发生
7. 选择现在离职的原因 -> 深挖出绩效考核问题【下次需要避免，一定要想好一个离职原因，天衣无缝】
8. 3、5年的规划
9. 怎么看待前几面的面试官，哪一点让你记忆深刻
10. 现在是否有孩子
11. 当前薪资构成
12. 离职DDL是什么时候
#### 

### HC满了，新的一轮

1. 个人简介
2. 介绍项目中的亮点【需要好好总结】
3. 简单谈谈分布式系统，其有什么特性
4. 聊了聊Netty、ES的原理结构
5. 设计题-1：有一个40G的文件，每一行都有一个时间字段，怎样按时间进行重新排序并输出
> 今天工作中遇到一个问题：
> 
> 要求对28G的数据排序，数据的格式如下：
> 
> id  time
> 要求按时间升序排序
> 
> 已有的资源为64G内存，32核的服务器一台，需要在一个晚上（8小时）内跑出排序结果。
> 
> 一个直观的解法就是把数据全部加载进内存，然而实际操作并不可行，才加载了1/10不到的数据就已经使用了接近40G的内存了。
> 另一个解决思路是手动进行map reduce，分成若干小模块，小模块排序之后再逐一合并。这个思路实现起来代价也很高，逐一合并无法利用32核GPU，速度估计不达标。充分利用CPU的话，调度策略编码量估计不小……
> 
> 最后我们找到了一个超级巧妙的解决方案：
> 
> 按照日期划分文件，每天的数据单独输出成一个文件，由于我们的数据只是1~8月份的数据，故只划分为240多个文件，
> 每个文件只有119M，然后利用多核特性对每个文件进行排序，排好序后按文件名收尾连接就好了。
> 
> 桶排序思想，好巧妙！

6. 设计题-2：1亿用户，100个标签，每个用户有不同的标签，怎样根据用户查标签、根据标签查用户
- 使用bitmap表示用户所具有的标签
- 使用ES倒排索引表示标签对应的用户
- 写入的时候采用双写，写完后刷新缓存
7. 自己目前在技术上的优势和不足？【需要好好总结】
8. 

