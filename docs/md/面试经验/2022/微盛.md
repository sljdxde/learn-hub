#### 一轮
1. 项目介绍，人员投入
2. jvm内存模型
   - 虚拟机栈：局部变量、操作数栈、方法出口
   - 方法区：静态变量、常量、已被虚拟机加载的类信息
   - pc：当前线程的指示器
   - 堆：对象实例
   - 本地方法栈：native方法
3. 双端队列：Deque是一个双端队列接口，继承自Queue接口，Deque的实现类是LinkedList、ArrayDeque、LinkedBlockingDeque，其中LinkedList是最常用的
4. tcp（3次握手、4次挥手）：
   - 3次握手：tcpdump -i lo port 8002
      - 1: 客户端向服务端发送syn，携带了初始序列化 num
      - 2: 服务端向客户端返回syn + ack，其中syn同，ack信息为 num+1
      - 3: 客户端返回ack+1
   - 4次挥手：
      - 1: 客户端向服务端发送 FIN=1，其序列号为seq=u
      - 2: 服务端收到后，返回 ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态
      - 2.1: 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文
      - 3: 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认
      - 4: 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态
   - 【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？
   - 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
5. 线程池：参数、类型
6. mysql - 索引：
7. mysql - 慢查询：
8. mysql - 优化：执行计划
9. java中的锁：[https://www.cnblogs.com/jyroy/p/11365935.html](https://www.cnblogs.com/jyroy/p/11365935.html)
   - 乐观锁 vs 悲观锁
   - 可重入 vs 不可重入
   - 自旋 vs 。。。
   - 公平 vs 非公平
10. 排序算法复杂度分析：
   - 归并排序：
   - 插入排序：
   - 堆排序：
11. mysql - 联合索引的考察：
